41. First Missing Positive

class Solution(object):
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        ls = len(nums)
        index = 0
        while index < ls:
            if nums[index] <= 0 or nums[index] > ls or nums[nums[index]-1] == nums[index]:
                index += 1
            else:
                pos = nums[index] - 1
                nums[index], nums[pos] = nums[pos], nums[index]
        res = 0
        while res < ls and nums[res] == res + 1:
            res += 1
        return res + 1
        
42. Trapping Rain Water

class Solution(object):
    def trap(self, height):
        ls = len(height)
        if ls == 0:
            return 0
        res, left = 0, 0
        while left < ls and height[left] == 0:
            left += 1
        pos = left + 1
        while pos < ls:
            if height[pos] >= height[left]:
                res += self.rain_water(height, left, pos)
                left = pos
                pos += 1
            elif pos == ls - 1:
                max_value, max_index = 0, pos
                for index in range(left+1, ls):
                    if height[index] > max_value:
                        max_value = height[index]
                        max_index = index
                res += self.rain_water(height, left, max_index)
                left = max_index
                pos = left + 1
            else:
                pos += 1
        return res
    
    def rain_water(self, height, start, end):
        if end - start  <= 1:
            return 0
        min_m = min(height[start], height[end])
        res = min_m*(end-start-1)
        step = 0
        for index in range(start+1, end):
            if height[index] > 0:
                step += height[index]
        return res - step
        
 43. Multiply Strings
 
 class Solution:
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        if num1 == "0" or num2 == "0":
            return "0"
        x = 0
        for i in range(len(num1)):
            x += int(num1[i])*10**(len(num1)-1-i)
        
        y = 0
        for i in range(len(num2)):
            y += int(num2[i])*10**(len(num2)-1-i)
        
        prod = x*y
        
        string = ""
        while prod > 0:
            string += str(prod % 10)
            prod //= 10
        
        return string[::-1]
        
 44. Wildcard Matching
 
 class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        
        f = [[None]*(len(p)+1) for _ in range(len(s)+1)]
        f[0][0] = True
        for j in range(1, len(p)+1):
            if p[j-1] == "*":
                f[0][j] = f[0][j-1]
            else:
                f[0][j] = False
        for i in range(1, len(s)+1):
            f[i][0] = False
            
        for i in range(1, len(s)+1):
            for j in range(1, len(p)+1):
                if p[j-1] not in "?*":
                    if s[i-1] != p[j-1]:
                        f[i][j] = False
                    else:
                        f[i][j] = f[i-1][j-1]
                else:
                    if p[j-1] == '?':
                        f[i][j] = f[i-1][j-1]
                    else:
                        f[i][j] = (f[i-1][j] or f[i][j-1])
        return f[-1][-1]
        
 45. Jump Game II
 
 class Solution:
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) <= 1:
            return 0
        end = 0 + nums[0]
        start = 0
        step = 1
        maxDis = 0 + nums[0]
        while end < len(nums) - 1:
            for i in range(start + 1, end + 1):
                # greedy
                maxDis = max(maxDis, nums[i] + i)
            start = end
            end = maxDis
            step += 1
        return step
        
46. Permutations

class Solution:

    def permute(self, nums):
        # DPS with swapping
        res = []
        if len(nums) == 0:
            return res
        self.get_permute(res, nums, 0)
        return res

    def get_permute(self, res, nums, index):
        if index == len(nums):
            res.append(list(nums))
            return
        for i in range(index, len(nums)):
            nums[i], nums[index] = nums[index], nums[i]
            # s(n) = 1 + s(n-1)
            self.get_permute(res, nums, index + 1)
            nums[i], nums[index] = nums[index], nums[i]
            
class Solution(object):
    def permute(self, nums):
        return [[n]+p for i, n in enumerate(nums) for p in self.permute(nums[:i]+ nums[i+1:])] or [[]] 
        
48. Rotate Image

class Solution(object):
    def rotate(self, matrix):
        if matrix is None or len(matrix)==1:
            return
        ls = len(matrix)
        for i in range(ls//2):
            begin, end = i, ls - 1 - i
            for k in range(ls - 2*i - 1):
                temp = matrix[end - k][begin]
                matrix[end - k][begin] = matrix[end][end - k]
                matrix[end][end - k] = matrix[begin + k][end]
                matrix[begin + k][end] = matrix[begin][begin + k]
                matrix[begin][begin + k] = temp
        return
        
49. Group Anagrams

class Solution(object):
    
    def groupAnagrams(self, strs):
        strs.sort()
        hash = {}
        for s in strs:
            key = self.hash_key(s)
            try:
                hash[key].append(s)
            except KeyError:
                hash[key] = [s]
        return hash.values()

    def hash_key(self, s):
        # hash string with 26 length array
        table = [0] * 26
        for ch in s:
            index = ord(ch) - ord('a')
            table[index] += 1
        return str(table)
        
50. Pow(x, n)
 
 class Solution:
    
    def myPow(self, x, n):
        
        if n == 0:
            return 1
        res, curr = 1, abs(n)
        while curr > 0:
            if curr & 1 == 1:
                res *= x
            curr >>= 1
            x *= x
        if n < 0:
            return 1 / res
        return  res
        
51. N-Queens

class Solution:
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        def DFS(queens, xy_diff, xy_sum):
            p = len(queens)
            if p == n:
                result.append(queens)
                return None
            for q in range(n):
                if (q not in queens) and (p-q not in xy_diff) and (p+q not in xy_sum):
                    DFS(queens+[q], xy_diff+[p-q], xy_sum+[p+q])
        result = []
        DFS([], [], [])
        return [['.'*i + 'Q' + '.'*(n-1-i) for i in sol] for sol in result]
        
class Solution:
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        def dfs(i,path):
            for j in range(n):
                if j in columns or (i-j) in negative or (i+j) in positive:
                    continue
                else:
                    tmp = "."*(j) + "Q" + "."*(n-j -1)
                    path.append(tmp)
                    columns.add(j)
                    negative.add((i-j))
                    positive.add((i+j))
                    if len(path) == n :
                        res.append(path[:])
                    else:

                        dfs(i+1,path[:])
                    columns.discard(j)
                    negative.discard((i-j))
                    positive.discard((i+j))
                    path.pop()
        
        if n <= 0:return []
        rows = set()
        columns = set()
        positive = set()
        negative = set()
        res = []
        dfs(0,[])
        
52. N-Queens II

class Solution:
    def totalNQueens(self, n):
        """
        :type n: int
        :rtype: int
        """
        res, y_stack, x_minus_y_stack, x_plus_y_stack = [], [], [], []
        
        def dfs(x=0):
            if x == n:
                res.append(['.'*y + 'Q' + '.'*(n-1-y) for y in y_stack])
                return
            for y in range(n):
                if (y not in y_stack) and (x-y not in x_minus_y_stack) and (x+y not in x_plus_y_stack):
                    y_stack.append(y)
                    x_minus_y_stack.append(x-y)
                    x_plus_y_stack.append(x+y)
                    dfs(x+1)  # increasing depth
                    y_stack.pop()
                    x_minus_y_stack.pop()
                    x_plus_y_stack.pop()
        dfs()  # default is x = 0
        if res:
            return len(res)
        else:
            return 0
            
 53. Maximum Subarray
 
 class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # Kadane's algorithm
        max_so_far = -float('inf')
        max_ending_here = 0
        for i in range(len(nums)):
            max_ending_here += nums[i]
            max_so_far = max(max_so_far, max_ending_here)
            if max_ending_here < 0:
                max_ending_here = 0
        return max_so_far
        
55. Jump Game

class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        # greedy
        # https://leetcode.com/articles/jump-game/
        length = len(nums)
        begin = length - 1
        for i in reversed(range(length - 1)):
            if i + nums[i] >= begin:
                begin = i
        return not begin
        
       
